package com.vibe.fundsmith.service;

import com.vibe.fundsmith.model.Trade;
import com.vibe.fundsmith.model.TradeSide;
import com.vibe.fundsmith.model.TradeStatus;
import com.vibe.fundsmith.repository.TradeRepository;
import com.vibe.fundsmith.dto.TradeRequest;
import com.vibe.fundsmith.dto.TradeResponse;
import com.vibe.fundsmith.exception.ValidationException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.regex.Pattern;

@Service
public class TradeService {
    private static final Logger log = LoggerFactory.getLogger(TradeService.class);
    private static final Pattern ISIN_PATTERN = Pattern.compile("^[A-Z0-9]{12}$");
    
    private final TradeRepository tradeRepository;
    private final PositionService positionService;
    private final CashService cashService;
    private final JournalService journalService;

    @Autowired
    public TradeService(TradeRepository tradeRepository,
                       PositionService positionService,
                       CashService cashService,
                       JournalService journalService) {
        this.tradeRepository = tradeRepository;
        this.positionService = positionService;
        this.cashService = cashService;
        this.journalService = journalService;
    }

    /**
     * Book a trade and update related systems (positions, cash)
     * 
     * @param request Trade request object
     * @return TradeResponse with trade ID and status
     */
    @Transactional
    public TradeResponse bookTrade(TradeRequest request) {
        validateTradeRequest(request);
        
        // Check for idempotency first
        UUID tradeId = request.getTradeId() != null ? request.getTradeId() : UUID.randomUUID();
        Optional<Trade> existingTrade = findTradeByTradeId(tradeId);
        
        if (existingTrade.isPresent()) {
            log.info("Trade {} already exists - idempotent operation", tradeId);
            return new TradeResponse(tradeId, existingTrade.get().getStatus().toString(), true);
        }
        
        // Default values for optional fields
        TradeSide side = request.getSide() != null ? request.getSide() : TradeSide.BUY;
        String tradeCurrency = request.getTradeCurrency() != null ? request.getTradeCurrency() : "USD";
        String portfolioId = request.getPortfolioId() != null ? request.getPortfolioId() : "DEFAULT";
        
        LocalDate settleDate = request.getSettleDate() != null 
            ? request.getSettleDate() 
            : calculateSettlementDate(request.getTradeDate());
        
        // Create and save trade
        Trade trade = new Trade(
            tradeId,
            request.getIsin(),
            request.getQuantity(),
            request.getPrice(),
            side,
            tradeCurrency,
            request.getTradeDate(),
            settleDate,
            portfolioId
        );
        
        // Mark synthetic trades (generated by DemoTradeGenerator)
        // We can identify these by the caller's stack trace or by setting a flag in the request
        // For now, let's assume any trade with a provided tradeId from the DemoTradeGenerator is synthetic
        boolean isSynthetic = request.getTradeId() != null;
        trade.setSynthetic(isSynthetic);
        
        Trade savedTrade = tradeRepository.save(trade);
        
        // Update position
        try {
            positionService.updatePosition(
                tradeId,
                request.getIsin(),
                new BigDecimal(request.getQuantity()),
                side
            );
        } catch (Exception e) {
            log.error("Failed to update position for trade {}", tradeId, e);
            throw new RuntimeException("Failed to update position: " + e.getMessage(), e);
        }
        
        // Update cash
        try {
            cashService.recordTradeImpact(
                tradeId,
                side,
                new BigDecimal(request.getQuantity()),
                request.getPrice(),
                portfolioId
            );
        } catch (Exception e) {
            log.error("Failed to update cash for trade {}", tradeId, e);
            throw new RuntimeException("Failed to update cash: " + e.getMessage(), e);
        }
        
        // Create accounting journal entries
        try {
            journalService.createTradeDateJournal(
                tradeId,
                request.getIsin(),
                new BigDecimal(request.getQuantity()),
                request.getPrice(),
                side
            );
        } catch (Exception e) {
            log.error("Failed to create journal for trade {}", tradeId, e);
            throw new RuntimeException("Failed to create journal: " + e.getMessage(), e);
        }
        
        log.info("Successfully booked trade {}: {} {} of {} at {}", 
            tradeId, side, request.getQuantity(), request.getIsin(), request.getPrice());
        
        return new TradeResponse(tradeId, TradeStatus.NEW.toString(), false);
    }

    /**
     * Find trades by various criteria
     */
    public List<Trade> findTrades(LocalDate fromDate, LocalDate toDate, String isin, Integer limit) {
        int actualLimit = limit != null ? limit : 50;
        PageRequest pageRequest = PageRequest.of(0, actualLimit);
        
        if (fromDate != null && toDate != null) {
            return isin != null 
                ? tradeRepository.findByIsinAndTradeDateBetweenOrderByCreatedAtDescIdDesc(isin, fromDate, toDate, pageRequest)
                : tradeRepository.findByTradeDateBetweenOrderByCreatedAtDescIdDesc(fromDate, toDate, pageRequest);
        }
        
        return isin != null
            ? tradeRepository.findByIsinOrderByCreatedAtDescIdDesc(isin, pageRequest)
            : tradeRepository.findByOrderByCreatedAtDescIdDesc(pageRequest);
    }
    
    /**
     * Delete all trades (for testing/demo)
     */
    @Transactional
    public long deleteAllTrades() {
        long count = tradeRepository.count();
        tradeRepository.deleteAll();
        return count;
    }
    
    /**
     * Find a trade by its trade ID
     */
    public Optional<Trade> findTradeByTradeId(UUID tradeId) {
        return tradeRepository.findByTradeId(tradeId);
    }

    /**
     * Validate trade request
     */
    private void validateTradeRequest(TradeRequest request) {
        if (!ISIN_PATTERN.matcher(request.getIsin()).matches()) {
            throw new ValidationException("isin", "Invalid ISIN format");
        }
        
        if (request.getQuantity() <= 0) {
            throw new ValidationException("quantity", "Quantity must be positive");
        }
        
        if (request.getPrice().signum() <= 0) {
            throw new ValidationException("price", "Price must be positive");
        }
        
        if (request.getTradeDate() == null) {
            throw new ValidationException("tradeDate", "Trade date is required");
        }
        
        if (request.getTradeDate().isAfter(LocalDate.now())) {
            throw new ValidationException("tradeDate", "Trade date cannot be in the future");
        }
        
        if (request.getSettleDate() != null && request.getSettleDate().isBefore(request.getTradeDate())) {
            throw new ValidationException("settleDate", "Settlement date cannot be before trade date");
        }
        
        // Currently only supporting BUY trades
        if (request.getSide() == TradeSide.SELL) {
            throw new ValidationException("side", "SELL trades not supported yet");
        }
    }

    /**
     * Calculate settlement date
     */
    private LocalDate calculateSettlementDate(LocalDate tradeDate) {
        LocalDate settleDate = tradeDate;
        int daysToAdd = 2;
        
        while (daysToAdd > 0) {
            settleDate = settleDate.plusDays(1);
            if (!isWeekend(settleDate)) {
                daysToAdd--;
            }
        }
        
        return settleDate;
    }

    /**
     * Check if date is weekend
     */
    private boolean isWeekend(LocalDate date) {
        DayOfWeek day = date.getDayOfWeek();
        return day == DayOfWeek.SATURDAY || day == DayOfWeek.SUNDAY;
    }
}